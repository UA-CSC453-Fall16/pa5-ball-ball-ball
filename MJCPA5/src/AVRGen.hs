
-- AVRGen.hs
--
-- Step (6) of compiling. Final step.
--
-- AVRGen Module uses the AST generated by Parser.hs and the symbold table generated by BuildST.hs
-- to generate the AVR code for the program.
--

module AVRGen where

import Util
import TypeCheck
import SymbolTable

-- search for the below comment to find the entry point at Prog
{-
    AVR Code Gen Entry Point
-}

avrCodeGen :: (AST, SymbolTable) -> Int -> (Int, String)
avrCodeGen ((MainClass   child), st) label = avrCodeGen (child, st) label
avrCodeGen ((Return      child), st) label = avrCodeGen (child, st) label

-- post-order traverse to next child statement to get its AVR code string(s), 
-- then return that string
avrCodeGen (Epsilon, _)   label = (label, "")
avrCodeGen ((Body []), _) label = (label, "")
avrCodeGen ((Body (stmt:stmts)), st) label
    = let
        (newLabel, codeStr1) = avrCodeGen (stmt, st) label
        (newLabel2, codeStr2) = avrCodeGen ((Body stmts), st) newLabel
    in
        (newLabel2, codeStr1 ++ codeStr2)

--Literals
avrCodeGen ((IntLiteral i), _) label
    = (label, 
      "\n    #Load int "++(show i)++ "\n"
    ++ "    ldi r24,lo8("++(show i)++ ")\n"
    ++ "    ldi r25,hi8("++(show i)++ ")\n"
    ++ "    # push two byte expression onto stack\n"
    ++ "    push r25\n"
    ++ "    push r24\n\n")


-- from a color literal expression leaf to AVR code string
avrCodeGen ((ColorLiteral i), _) label
    = (label, 
      "    # Color expression Meggy.Color\n"
    ++ "    ldi r22,"++(show i)++ "\n"
    ++ "    # push one byte expression onto stack\n"
    ++ "    push r22\n")

avrCodeGen ((ButtonLiteral value), _) label
    = (label, value ++ "\n")
    
avrCodeGen ((Boolean value), _) label = 
    if value == True then
        (label,
           "    # True literal = 1\n"
        ++ "    ldi     r22, 1\n"
        ++ "    push    r22\n\n")
    else
        (label, 
           "    # False literal = 0\n"
        ++ "    ldi     r24, 0\n"
        ++ "    push    r24\n\n")

avrCodeGen ((Identifier id), st) label = 
    let
        id_type = tCheck ((Identifier id), st)
        offset  = lookupParamOffset st id 
    in
        if id_type == IntType then 
            (label, 
               "    #Load identifier " ++ id ++ "\n"
            ++ "    ldd r25, Y + " ++ (show offset) ++ "\n"
            ++ "    ldd r24, Y + " ++ (show (offset - 1)) ++ "\n"
            ++ "    push r25\n"
            ++ "    push r24\n\n"
            )
        else 
            (label, 
               "    #Load identifier " ++ id ++ "\n"
            ++ "    ldd r24, Y + " ++ show offset ++ "\n"
            ++ "    push r24\n\n"
            )

-- Unary statements
avrCodeGen ((Delay child), st) label = 
    let
        (newLabel, code) = avrCodeGen (child, st) label
    in
        (newLabel, code
        ++ "    \n### Meggy.delay() call\n"
        ++ "    # load delay parameter\n"
        ++ "    # load a two byte expression off stack\n"
        ++ "    pop    r24\n"
        ++ "    pop    r25\n"
        ++ "    call   _Z8delay_msj\n")

avrCodeGen ((CheckButton child), st) label =
    let
        (newLabel, code) = avrCodeGen (child, st) label
    in
        (newLabel + 3,
           "    ### MeggyCheckButton\n"
        ++ "    call    _Z16CheckButtonsDownv\n"
        ++ "    lds    r24, Button_" ++ code
        ++ "    # if button value is zero, push 0 else push 1\n"
        ++ "    tst    r24\n"
        ++ "    breq   MJ_L" ++ (show newLabel) ++ "\n"
        ++ "MJ_L" ++ (show (newLabel+1)) ++ ":\n"
        ++ "    ldi    r24, 1\n"
        ++ "    jmp    MJ_L" ++ (show (newLabel+2)) ++ "\n"
        ++ "MJ_L" ++ (show newLabel) ++ ":\n"
        ++ "MJ_L" ++ (show (newLabel+2)) ++ ":\n"
        ++ "    # push one byte expression onto stack\n"
        ++ "    push   r24\n")

avrCodeGen ((LogicalNot child), st) label = 
    let
        (newLabel, code) = avrCodeGen (child, st) label
    in
        (newLabel, code
        ++ "    # !(expression) - Logical Negation\n"
        ++ "    pop     r24\n"
        ++ "    ldi     r22, 1\n"
        ++ "    eor     r24, r22\n"
        ++ "    # push negated expression onto the stack\n"
        ++ "    push    r24\n\n")

avrCodeGen ((UnaryMinus child), st) label 
    | tCheck (child, st)== ByteType =
        (newLabel+2, code
        ++ "    # neg byte\n"
        ++ "    # load a one byte expression off stack\n"
        ++ "    pop    r18\n"
        ++ "    ldi    r20, 0\n"
        ++ "    sub    r20, r18\n"
        ++ "    # push two byte expression onto stack\n"
        ++ "    push   r20\n")
    | tCheck (child, st) == IntType =
        (newLabel+2, code
        ++ "    # neg int\n"
        ++ "    # load a two byte expression off stack\n"
        ++ "    pop    r24\n"
        ++ "    pop    r25\n"
        ++ "    ldi    r22, 0\n"
        ++ "    ldi    r23, 0\n"
        ++ "    sub    r22, r24\n"
        ++ "    sbc    r23, r25\n"
        ++ "    # push two byte expression onto stack\n"
        ++ "    push   r23\n"
        ++ "    push   r22\n")
    | otherwise = error("Error in generating code for unary minus expression")
    where
        (newLabel, code) = avrCodeGen (child, st)label

-- from a byte cast expression of its child to AVR code string
avrCodeGen ((ByteCast bcExp), st) label  
    | typeChild == ByteType = (newLabel, bcExpStr)
    | otherwise = 
        (newLabel, bcExpStr
        ++ "    # Casting expression to byte by popping\n"
        ++ "    # 2 bytes off stack and only pushing low order bits\n"
        ++ "    # back on. Low order bits are on top of stack.\n"
        ++ "    pop   r24\n"
        ++ "    pop   r25\n"
        ++ "    push  r24\n")
    where
        (newLabel, bcExpStr) = avrCodeGen (bcExp, st)label
        typeChild = tCheck (bcExp, st)
        

avrCodeGen ((ParenExp child), st) label = avrCodeGen (child, st) label

--Binary statements
avrCodeGen ((GetPixel child1 child2), st) label = 
    let
        (newLabel1, exp1) = avrCodeGen (child1, st) label
        (newLabel2, exp2) = avrCodeGen (child2, st) newLabel1
    in
       (newLabel2, exp1 ++ "\n" ++ exp2 ++ "\n"
    ++ "    ### Meggy.getPixel call\n"
    ++ "    pop     r22\n"
    ++ "    pop     r24\n"
    ++ "    call    _Z6ReadPxhh\n"
    ++ "    push    r24\n"
    ++ "    ### End Meggy.getPixel call\n")

avrCodeGen ((LogicalAnd child1 child2), st) label =
    let
        (newLabel1, code1) = avrCodeGen (child1, st) label
        (newLabel2, code2) = avrCodeGen (child2, st) newLabel1
    in
        ( (newLabel2 + 3), 
           "    #Short circuited && operation\n"
        ++ "    # &&: left operand\n"
        ++ code1 ++ "\n"
        ++ "    # &&: if left operand is false do not eval right\n"
        ++ "    # pop the true from the stack\n"
        ++ "    pop     r24\n"
        ++ "    push    r24\n"
        ++ "    # compare left operand with zero\n"
        ++ "    ldi     r25, 0\n"
        ++ "    cp      r24, r25\n"
        ++ "    # if left is false short circuit out\n"
        ++ "    brne    MJ_L" ++ (show (newLabel2 + 2)) ++ "\n"
        ++ "    jmp     MJ_L" ++ (show (newLabel2 + 1)) ++ "\n"
        ++ "MJ_L" ++ (show (newLabel2 + 2)) ++ ":\n"
        ++ "    # right operand\n"
        ++ "    pop     r24\n"
        ++ code2 ++ "\n"
        ++ "    pop    r24\n"
        ++ "    push   r24\n"
        ++ "MJ_L" ++ (show (newLabel2 + 1)) ++ ":\n")


avrCodeGen ((LogicalEqual child1 child2), st) label 
    | tCheck (child1, st) == IntType && tCheck (child2, st) == IntType =
        ( (newLabel2 + 4), code1 ++ "\n" ++ code2 ++ "\n"
            ++ "    # equality check expression for two ints\n"
            ++ "    pop     r18\n"
            ++ "    pop     r19\n\n"
            ++ "    pop     r24\n"
            ++ "    pop     r25\n\n"
            ++ "    # Do comparasin \n"
            ++ "    cp      r24, r18\n"
            ++ "    cpc     r25, r19\n\n"
            ++ "    breq MJ_L" ++ (show (newLabel2 + 2)) ++ "\n"
            ++ "    # result is false\n"
            ++ "MJ_L" ++ (show (newLabel2 + 1)) ++ ":\n"
            ++ "    ldi     r24, 0\n"
            ++ "    jmp     MJ_L" ++ (show (newLabel2 + 3)) ++ "\n"
            ++ "    # result is true\n"
            ++ "MJ_L" ++ (show (newLabel2 + 2)) ++ ":\n"
            ++ "    ldi     r24, 1\n"
            ++ "    # store result of equal expression\n"
            ++ "MJ_L" ++ (show (newLabel2 + 3)) ++ ":\n"
            ++ "    push    r24\n")

    | tCheck (child1, st) == ByteType && tCheck (child2, st) == IntType =
        ( (newLabel2 + 6) , code1 ++ "\n" ++  code2 ++ "\n"
            ++ "    # equality check expression for an int and a byte\n"
            ++ "    pop     r18\n"
            ++ "    pop     r19\n\n"
            ++ "    pop     r24\n\n"
            ++ promoteByteToInt child2 newLabel2 ++ "\n"
            ++ "    # Do comparasin \n"
            ++ "    cp      r24, r18\n"
            ++ "    cpc     r25, r19\n\n"
            ++ "    breq MJ_L" ++ (show (newLabel2 + 4)) ++ "\n"
            ++ "    # result is false\n"
            ++ "MJ_L" ++ (show (newLabel2 + 3)) ++ ":\n"
            ++ "    ldi     r24, 0\n"
            ++ "    jmp     MJ_L" ++ (show (newLabel2 + 5)) ++ "\n"
            ++ "    # result is true\n"
            ++ "MJ_L" ++ (show (newLabel2 + 4)) ++ ":\n"
            ++ "    ldi     r24, 1\n"
            ++ "    # store result of equal expression\n"
            ++ "MJ_L" ++ (show (newLabel2 + 5)) ++ ":\n"
            ++ "    push    r24\n")

    | tCheck (child1, st) == IntType && tCheck (child2, st) == ByteType =
        ( (newLabel2 + 6) , code1 ++ "\n" ++ code2 ++ "\n"
            ++ "    # equality check expression for a byte and an int\n"
            ++ "    pop     r18\n"
            ++ "    pop     r24\n"
            ++ "    pop     r25\n\n"
            ++ promoteByteToInt' child1 newLabel2 ++ "\n"
            ++ "    # Do comparasin \n"
            ++ "    cp      r24, r18\n"
            ++ "    cpc     r25, r19\n\n"
            ++ "    breq MJ_L" ++ (show (newLabel2 + 4)) ++ "\n"
            ++ "    # result is false\n"
            ++ "MJ_L" ++ (show (newLabel2 + 3)) ++ ":\n"
            ++ "    ldi     r24, 0\n"
            ++ "    jmp     MJ_L" ++ (show (newLabel2 + 5)) ++ "\n"
            ++ "    # result is true\n"
            ++ "MJ_L" ++ (show (newLabel2 + 4)) ++ ":\n"
            ++ "    ldi     r24, 1\n"
            ++ "    # store result of equal expression\n"
            ++ "MJ_L" ++ (show (newLabel2 + 5)) ++ ":\n"
            ++ "    push    r24\n")

    | tCheck (child1, st) == ByteType && tCheck (child2, st) == ByteType = 
        ( (newLabel2 + 8) , code1 ++ "\n" ++ code2 ++ "\n"
            ++ "    # equality check expression for two byte expressions\n"
            ++ "    pop     r18\n"
            ++ "    pop     r19\n\n"
            ++ promoteByteToInt' child1 newLabel2 ++ "\n"
            ++ promoteByteToInt child2 (newLabel2 + 2) ++ "\n"
            ++ "    # Do comparasin \n"
            ++ "    cp      r24, r18\n"
            ++ "    cpc     r25, r19\n\n"
            ++ "    breq MJ_L" ++ (show (newLabel2 + 6)) ++ "\n"
            ++ "    # result is false\n"
            ++ "MJ_L" ++ (show (newLabel2 + 5)) ++ ":\n"
            ++ "    ldi     r24, 0\n"
            ++ "    jmp     MJ_L" ++ (show (newLabel2 + 7)) ++ "\n"
            ++ "    # result is true\n"
            ++ "MJ_L" ++ (show (newLabel2 + 6)) ++ ":\n"
            ++ "    ldi     r24, 1\n"
            ++ "    # store result of equal expression\n"
            ++ "MJ_L" ++ (show (newLabel2 + 7)) ++ ":\n"
            ++ "    push    r24\n")

    | tCheck (child1, st) == MeggyColorType && tCheck (child2, st) == MeggyColorType =
        ( (newLabel2 + 4), code1 ++ "\n" ++ code2 ++ "\n"
            ++ "    # equality check expression for colors\n"
            ++ "    pop     r18\n"
            ++ "    pop     r24\n\n"
            ++ "    # Do comparasin \n"
            ++ "    cp      r24, r18\n\n"
            ++ "    breq MJ_L" ++ (show (newLabel2 + 2)) ++ "\n"
            ++ "    # result is false\n"
            ++ "MJ_L" ++ (show (newLabel2 + 1)) ++ ":\n"
            ++ "    ldi     r24, 0\n"
            ++ "    jmp     MJ_L" ++ (show (newLabel2 + 3)) ++ "\n"
            ++ "    # result is true\n"
            ++ "MJ_L" ++ (show (newLabel2 + 2)) ++ ":\n"
            ++ "    ldi     r24, 1\n"
            ++ "    # store result of equal expression\n"
            ++ "MJ_L" ++ (show (newLabel2 + 3)) ++ ":\n"
            ++ "    push    r24\n")

    | tCheck (child1, st) == BooleanType && tCheck (child2, st) == BooleanType =
        ( (newLabel2 + 4), code1 ++ "\n" ++ code2 ++ "\n"
            ++ "    # equality check expression\n"
            ++ "    pop     r18\n"
            ++ "    pop     r24\n\n"
            ++ "    # Do comparasin \n"
            ++ "    cp      r24, r18\n\n"
            ++ "    breq MJ_L" ++ (show (newLabel2 + 2)) ++ "\n"
            ++ "    # result is false\n"
            ++ "MJ_L" ++ (show (newLabel2 + 1)) ++ ":\n"
            ++ "    ldi     r24, 0\n"
            ++ "    jmp     MJ_L" ++ (show (newLabel2 + 3)) ++ "\n"
            ++ "    # result is true\n"
            ++ "MJ_L" ++ (show (newLabel2 + 2)) ++ ":\n"
            ++ "    ldi     r24, 1\n"
            ++ "    # store result of equal expression\n"
            ++ "MJ_L" ++ (show (newLabel2 + 3)) ++ ":\n"
            ++ "    push    r24\n")

    | otherwise = error("Error in generating code for equality expression")
    where 
        (newLabel1, code1) = avrCodeGen (child1, st) label
        (newLabel2, code2) = avrCodeGen (child2, st) newLabel1

avrCodeGen ((Add child1 child2), st) label =
    let
        (newLabel1, code1) = avrCodeGen (child1, st) label
        (newLabel2, code2) = avrCodeGen (child2, st) newLabel1
    in
        -- generate pops for integers and bytes (load 0 into upper bits for bytes)
        if tCheck (child1, st) == IntType && tCheck (child2, st) == IntType then
            (newLabel2, code1 ++ "\n" ++ code2 ++ "\n"
            ++ "    # Operands are Ints: \n"
            ++ "    # get first operand in 18 and 19\n"
            ++ "    pop     r18\n"
            ++ "    pop     r19\n"
            ++ "    #get second operand in 24 and 25\n"
            ++ "    pop     r24\n"
            ++ "    pop     r25\n\n"
            ++ "    # Do add operation\n"
            ++ "    add     r24, r18\n"
            ++ "    adc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")
        else if tCheck (child1, st) == ByteType && tCheck (child2, st) == IntType then
            (newLabel2 + 2, code1 ++ code2
            ++ "    # Operands are Int and Byte: \n"
            ++ "    # get first operand (an int) in 18 and 19\n"
            ++ "    pop     r18\n"
            ++ "    pop     r19\n"
            ++ "    #get second operand (one byte) in 24\n"
            ++ "    pop     r24\n\n"
            ++ promoteByteToInt child2 newLabel2 ++ "\n"
            ++ "    # Do add operation\n"
            ++ "    add     r24, r18\n"
            ++ "    adc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")
        else if tCheck (child1, st) == IntType && tCheck (child2, st) == ByteType then
            (newLabel2 + 2, code1 ++ code2
            ++ "    # Operands are Byte and Int: \n"
            ++ "    # get first operand (one byte) in 18\n"
            ++ "    pop     r18\n"
            ++ "    #get second operand (an int) in 24 and 25\n"
            ++ "    pop     r24\n"
            ++ "    pop     r25\n\n"
            ++ promoteByteToInt' child1 newLabel2
            ++ "    # Do add operation\n"
            ++ "    add     r24, r18\n"
            ++ "    adc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")
        else
            (newLabel2 + 4, code1 ++ code2
            ++ "    # Operands are Bytes: \n"
            ++ "    # get first operand (one byte) in 18\n"
            ++ "    pop     r18\n"
            ++ "    #get second operand in 24 and 25\n"
            ++ "    pop     r24\n\n"
            ++ promoteByteToInt' child1 newLabel2 ++ "\n"
            ++ promoteByteToInt  child2 (newLabel2 + 2) ++ "\n"
            ++ "    # Do add operation\n"
            ++ "    add     r24, r18\n"
            ++ "    adc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")

avrCodeGen ((Sub child1 child2), st) label =
    let
        (newLabel1, code1) = avrCodeGen (child1, st) label
        (newLabel2, code2) = avrCodeGen (child2, st) newLabel1
    in
        -- generate pops for integers and bytes (load 0 into upper bits for bytes)
        if tCheck (child1, st) == IntType && tCheck (child2, st) == IntType then
            (newLabel2, code1 ++ code2
            ++ "    # Operands are Ints: \n"
            ++ "    # get first operand in 18 and 19\n"
            ++ "    pop     r18\n"
            ++ "    pop     r19\n"
            ++ "    # get second operand in 24 and 25\n"
            ++ "    pop     r24\n"
            ++ "    pop     r25\n\n"
            ++ "    # Do add operation\n"
            ++ "    sub     r24, r18\n"
            ++ "    sbc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")
        else if tCheck (child1, st) == ByteType && tCheck (child2, st) == IntType then
            (newLabel2 + 2, code1 ++ code2
            ++ "    # Operands are Int and Byte: \n"
            ++ "    # get first operand (an int) in 18 and 19\n"
            ++ "    pop     r18\n"
            ++ "    pop     r19\n"
            ++ "    # get second operand (one byte) in 24\n"
            ++ "    pop     r24\n\n"
            ++ promoteByteToInt child2 newLabel2
            ++ "    # Do add operation\n"
            ++ "    sub     r24, r18\n"
            ++ "    sbc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")
        else if tCheck (child1, st) == IntType && tCheck (child2, st) == ByteType then
            (newLabel2 + 2, code1 ++ code2
            ++ "    # Operands are Byte and Int: \n"
            ++ "    # get first operand (one byte) in 18\n"
            ++ "    pop     r18\n"
            ++ "    #get second operand (an int) in 24 and 25\n"
            ++ "    pop     r24\n"
            ++ "    pop     r25\n\n"
            ++ promoteByteToInt' child1 newLabel2
            ++ "    # Do add operation\n"
            ++ "    sub     r24, r18\n"
            ++ "    sbc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")
        else
            (newLabel2 + 4, code1 ++ code2
            ++ "    # Operands are Bytes: \n"
            ++ "    # get first operand (one byte) in 18\n"
            ++ "    pop     r18\n"
            ++ "    # get second operand in 24 and 25\n"
            ++ "    pop     r24\n\n"
            ++ promoteByteToInt' child1 newLabel2 ++ "\n"
            ++ promoteByteToInt  child2 (newLabel2 + 2) ++ "\n"
            ++ "    # Do add operation\n"
            ++ "    sub     r24, r18\n"
            ++ "    sbc     r25, r19\n"
            ++ "    push    r25\n"
            ++ "    push    r24\n")

avrCodeGen ((Mul child1 child2), st) label =
    let
        (newLabel1, code1) = avrCodeGen (child1, st) label
        (newLabel2, code2) = avrCodeGen (child2, st) newLabel1
    in
        (newLabel2, code1 ++ code2 
        ++ "    # Mul Expresion:\n"
        ++ "    pop    r18\n"
        ++ "    pop    r22\n"
        ++ "    # move low byte sources into destination registers\n"
        ++ "    mov    r24, r18\n"
        ++ "    mov    r26, r22\n\n"
        ++ "    # Do multiplication\n"
        ++ "    muls   r24, r26\n"
        ++ "    # Push result back on stack\n"
        ++ "    push   r1\n"
        ++ "    push   r0\n"
        ++ "    # clear intermediary registers\n"
        ++ "    eor    r0,r0\n"
        ++ "    eor    r1,r1\n")


avrCodeGen ((While child1 child2), st) label = 
    let
        (newLabel1, condition) = avrCodeGen (child1, st) label
        (newLabel2, whileBody) = avrCodeGen (child2, st) newLabel1
    in
    (newLabel2 + 3, 
       "\n    ### while statement\n"
    ++ "MJ_L" ++ (show (newLabel2 + 0)) ++ ":\n\n"
    ++ condition ++ "\n"
    ++ "    # if not(condition)\n"
    ++ "    # load a one byte expression off stack\n"
    ++ "    pop     r24\n"
    ++ "    ldi     r25, 0\n"
    ++ "    cp      r24, r25\n"
    ++ "    # WANT breq MJ_L" ++ (show (newLabel2 + 2)) ++ "\n"
    ++ "    brne    MJ_L" ++ (show (newLabel2 + 1)) ++ "\n"
    ++ "    jmp     MJ_L" ++ (show (newLabel2 + 2)) ++ "\n"
    ++ "\n    # while loop body\n"
    ++ "MJ_L" ++ (show (newLabel2 + 1)) ++ ":\n\n"
    ++ whileBody ++ "\n"
    ++ "\n    # jump to while test\n"
    ++ "    jmp     MJ_L" ++ (show (newLabel2 + 0)) ++ "\n"
    ++ "\n    # end of while\n"
    ++ "MJ_L" ++ (show (newLabel2 + 2)) ++ ":\n")

--Trinary statements
avrCodeGen ((If child1 child2 child3), st) label =
    let
        (newLabel1, condition) = avrCodeGen (child1, st) label
        (newLabel2, thenBody)  = avrCodeGen (child2, st) newLabel1
        (newLabel3, elseBody)  = avrCodeGen (child3, st) newLabel2
    in
        (newLabel3 + 3, 
           "    # condition to branch on:\n"  
        ++ condition ++ "\n"
        ++ "    # load if condition\n"
        ++ "    pop     r24\n"
        ++ "    #load 0 to compare to for branch condition\n"
        ++ "    ldi     r25, 0\n"
        ++ "    # cp will compare and set SREG flag\n"
        ++ "    cp      r24, r25\n"
        ++ "    # if they are not equal do a long jump to else body\n"
        ++ "    brne    MJ_L" ++ (show (newLabel3 + 0)) ++ "\n"
        ++ "    jmp     MJ_L" ++ (show (newLabel3 + 1)) ++ "\n\n"
        ++ "    # thenBody label for if statement\n"
        ++ "MJ_L" ++ (show (newLabel3 + 0)) ++ ":\n\n"
        ++ thenBody ++ "\n\n"
        ++ "    #break out of thenBody without executing else body\n"
        ++ "    jmp     MJ_L" ++ (show (newLabel3 + 2)) ++ "\n\n"
        ++ "    # elseBody label for if statement\n"
        ++ "MJ_L" ++ (show (newLabel3 + 1)) ++ ":\n\n"
        ++ elseBody ++ "\n\n"
        ++ "    #done label for if statement\n"
        ++ "MJ_L" ++ (show (newLabel3 + 2)) ++ ":\n\n")

-- from a Meggy.SetPixel statement, post-order traverse to child argumentsto 
-- get their AVR code strings, concatenate them, then prepend that tothe AVR 
-- code string for this function call
avrCodeGen ((SetPixel bc1 bc2 col), st) label =
    let
        (newLabel1, bc1str) = avrCodeGen (bc1, st) label
        (newLabel2, bc2str) = avrCodeGen (bc2, st) newLabel1
        (newLabel3, colstr) = avrCodeGen (col, st) newLabel2
    in
        (newLabel3, bc1str++bc2str++colstr
        ++ "    \n### Meggy.setPixel(x,y,color) call\n"
        ++ "    # load a one byte expression off stack\n"
        ++ "    pop     r20\n"
        ++ "    # load a one byte expression off stack\n"
        ++ "    pop     r22\n"
        ++ "    # load a one byte expression off stack\n"
        ++ "    pop     r24\n"
        ++ "    call    _Z6DrawPxhhh\n"
        ++ "    call    _Z12DisplaySlatev\n")

-- PA4 Code generation
avrCodeGen ((ToneLiteral t), st) label = 
      (label, 
      "\n    #Load Meggy Tone value "++(show t)++ "\n"
    ++ "    ldi r24,lo8(" ++ (show t) ++ ")\n"
    ++ "    ldi r25,hi8(" ++ (show t) ++ ")\n"
    ++ "    # push two byte expression onto stack\n"
    ++ "    push r25\n"
    ++ "    push r24\n\n")

avrCodeGen ((ToneStart color duration), st) label = 
    let
        (_, load_color)    = avrCodeGen (color, st) label
        (_, load_duration) = avrCodeGen (duration, st) label
    in
        (label, 
        load_color ++ load_duration 
        ++ "    ### Meggy.toneStart call\n"
        ++ "    # Load duration off the stack\n"
        ++ "    pop r22\n"
        ++ "    pop r23\n"
        ++ "    # Load color off the stack\n"
        ++ "    pop r24\n"
        ++ "    pop r25\n"
        ++ "    call _Z10Tone_Startjj\n"
        ++ "    ### End Meggy.ToneStart call\n\n")

{-
    AVR Code Gen Entry Point 
-}
avrCodeGen (Prog Epsilon [], st) label = (label, "")
avrCodeGen (Prog Epsilon (first_class:other_classes), st) label = 
    let 
        (label1, funct1)      = avrCodeGen (first_class, st) label
        (final_label, funct2) = (avrCodeGen ((Prog Epsilon other_classes), st) label1)
    in
        (final_label, funct1 ++ funct2)

avrCodeGen (Prog main (first_class:other_classes), st) label = 
    let 
        (label1, main_code)  = avrCodeGen (main, st) label
        (label2, functions)  = avrCodeGen (first_class, st) label1
        (final_label, funct) = (avrCodeGen ((Prog Epsilon other_classes), st) label2)
    in
        (final_label, header ++ main_code ++ footer ++ functions ++ funct)

avrCodeGen (Prog main [], st) label = 
    let 
        (final_label, main_code)  = avrCodeGen (main, st) label
    in
        (final_label, header ++ main_code ++ footer)

avrCodeGen ((Class  [] name), st) label = (label, "")
avrCodeGen ((Class  ((Method body method_name sig):methods) class_name), st) label =
    let
        id        = correctName (class_name ++ method_name)
        functHead = ("\n\n\n### Function Head\n    .text\n" ++ ".global " ++ id ++ "\n" ++ "   .type " ++ id ++ ", @function\n" ++ id ++ ":\n")
        functFoot = ("    #restore FP and return\n" ++ "    pop r28\n" ++ "    pop r29\n" ++ "    ret\n" ++ "    .size " ++ id ++ ", .-" ++ id ++ "\n")
        st1       = pushScope st class_name
        (label1, function) = avrCodeGen ((Method body method_name sig), st1) label
        function_complete = functHead ++ function ++ functFoot
        st2       = popScope st1
        (final_label, function_rest) = avrCodeGen ((Class methods class_name), st2) label
    in
        (final_label, function_complete ++ function_rest)

avrCodeGen ((Instance invocation class_name), st) label = 
    if class_name == "this" then
        let
            st1 = popScope st
            (final_label, fucntion_call_code) = avrCodeGen (invocation, st) label
        in
            (final_label,
            "    #Instantiation (new ... ()) \n" ++
            "    ldi r24, lo8(0)\n" ++
            "    ldi r25, hi8(0)\n" ++
            "    #push the (object) on the stack\n" ++
            "    push r25\n" ++
            "    push r24\n\n" ++ fucntion_call_code
            )
    else 
        let
            st1 = setProgScope st
            st2 = pushScope st1 class_name
            (final_label, fucntion_call_code) = avrCodeGen (invocation, st2) label
            st3 = popScope st2
        in
            (final_label,
            "    #Instantiation (new ... ()) \n" ++
            "    ldi r24, lo8(0)\n" ++
            "    ldi r25, hi8(0)\n" ++
            "    #push the (object) on the stack\n" ++
            "    push r25\n" ++
            "    push r24\n\n" ++ fucntion_call_code
            )

avrCodeGen ((Invoke list_of_params method_name), st) label = 
    let
        st1                               = pushScope st method_name
        (label1, param_evaluations)       = evaluateParams (list_of_params, st1) method_name label
        fucntion_call_code                = setUpFunctionCall st1
        st2                               = popScope st1
    in
        (label1, param_evaluations ++ fucntion_call_code)

avrCodeGen ((Method body method_name (TS params ret_type)), st@(SymTab progScope [class_name])) label =
    let
        st1 = pushScope st method_name
        id = correctName (class_name ++ method_name)
        methodPrologueCode = 
               "    push r29\n"
            ++ "    push r28\n"
            ++ "    # make space for locals and params\n"
            ++ "    ldi r30, 0\n"
            ++ (concat $ replicate (numBytesInParameters params 2) "    push r30\n") -- 2 for 'this'
          ++ "\n    # Copy stack pointer to frame pointer\n"
            ++ "    in     r28,__SP_L__\n"
            ++ "    in     r29,__SP_H__\n\n"
            ++ "    # save off parameters\n"
            ++ "    std Y + 2, r25\n"
            ++ "    std Y + 1, r24\n"
            ++ helpStoreMethodParams params st1 22
            ++ "/* done with function "++id++" prologue */\n\n"
        (new_label, methodBodyCode) = avrCodeGen (body, st1) label
        actual_return_type = tCheck (body, st1)
        methodEpilogueCode =
               "\n/* epilogue start for "++id++" */\n"
            ++ "    # handle return value\n"
            ++ helpLoadMethodReturnValue actual_return_type
            ++ "    # pop space off stack for parameters and locals\n"
            ++ (concat $ replicate (numBytesInParameters params 2) "    pop r30\n") -- 2 for 'this'
            ++ "    # restoring the frame pointer\n"
        st2 = popScope st1 -- NOT UNTIL AFTER DONE WITH BODY
    in
        (new_label, methodPrologueCode++methodBodyCode++methodEpilogueCode)
        

avrCodeGen ((LessThan operand1 operand2), st) label = 
    let
        type_op1 = tCheck (operand1, st) 
        type_op2 = tCheck (operand2, st)
        (label1, code_op1)      = avrCodeGen (operand1, st) label
        (final_label, code_op2) = avrCodeGen (operand2, st) label1
    in
        if type_op1 == ByteType && type_op2 == ByteType then 
            (final_label + 7, 
            code_op1 ++ code_op2
            ++ "    ### LessThan Expression"
            ++ avrPop type_op1 18 final_label ++ "\n"
            ++ avrPop type_op2 24 (final_label + 2) ++ "\n"
            ++ "    cp r24, r18\n"
            ++ "    cpc r25, r19\n"
            ++ "    brlt MJ_L"++show (final_label + 5) ++"\n\n"
            ++ "    #false\n"
            ++ "MJ_L"++show (final_label + 4) ++":\n"
            ++ "    ldi r24, 0\n"
            ++ "    jmp MJ_L"++show (final_label + 6)++"\n\n"
            ++ "    #true\n"
            ++ "MJ_L"++show (final_label + 5) ++":\n"
            ++ "    ldi r24, 1\n\n"
            ++ "    #push result of less than on stack\n"
            ++ "MJ_L" ++ show (final_label + 6) ++":\n"
            ++ "    push r24\n"
            ++ "    ### End Less Than expression\n\n"
            )
        else if (type_op1 == ByteType && type_op2 == IntType) || (type_op1 == IntType && type_op2 == ByteType) then 
            (final_label + 5, 
            code_op1 ++ code_op2
            ++ "    ### LessThan Expression"
            ++ avrPop type_op1 18 final_label
            ++ avrPop type_op2 24 final_label 
            ++ "    cp r24, r18\n"
            ++ "    cpc r25, r19\n"
            ++ "    brlt MJ_L"++show (final_label + 3) ++"\n\n"
            ++ "    #false\n"
            ++ "MJ_L"++show (final_label + 2) ++":\n"
            ++ "    ldi r24, 0\n"
            ++ "    jmp MJ_L"++show (final_label + 4)++"\n\n"
            ++ "    #true\n"
            ++ "MJ_L"++show (final_label + 3) ++":\n"
            ++ "    ldi r24, 1\n\n"
            ++ "    #push result of less than on stack\n"
            ++ "MJ_L" ++ show (final_label + 4) ++":\n"
            ++ "    push r24\n"
            ++ "    ### End Less Than expression\n\n"
            )
        else -- two int expressions 
            (final_label + 3, 
            code_op1 ++ code_op2
            ++ "    ### LessThan Expression"
            ++ avrPop type_op1 18 final_label
            ++ avrPop type_op2 24 final_label 
            ++ "    cp r24, r18\n"
            ++ "    cpc r25, r19\n"
            ++ "    brlt MJ_L"++show (final_label + 1) ++"\n\n"
            ++ "    #false\n"
            ++ "MJ_L"++show final_label ++":\n"
            ++ "    ldi r24, 0\n"
            ++ "    jmp MJ_L"++show (final_label + 2)++"\n\n"
            ++ "    #true\n"
            ++ "MJ_L"++show (final_label + 1) ++":\n"
            ++ "    ldi r24, 1\n\n"
            ++ "    #push result of less than on stack\n"
            ++ "MJ_L" ++ show (final_label + 2) ++":\n"
            ++ "    push r24\n"
            ++ "    ### End Less Than expression\n\n"
            )

avrCodeGen (x, st) label = error ("AST: " ++ show x)

--avrPop Pop one or two bytes depending on Type, into register Int (and Int + 1) return the avr code for this 
--       the AST is required for promoting byte to int, the last Int is the label #
avrPop :: Type -> Int -> Int -> String
avrPop IntType reg label = 
        "    #Load a two byte expression from the stack\n"
    ++  "    pop r" ++ show reg ++ "\n"
    ++  "    pop r" ++ show (reg+1) ++ "\n"
avrPop _ reg label =
    "    #Load a one byte expression from the stack\n"
    ++  "    pop r" ++ show reg ++ "\n"
    ++  promote reg label 

-- takes AST to promote, int label and int register
promote :: Int -> Int -> String
promote reg label =
       "    #promote byte to integer\n"
    ++ "    tst     r"++show reg++"\n"
    ++ "    brlt    MJ_L" ++ (show label) ++ "\n"
    ++ "    ldi     r"++show (reg+1)++", 0\n"
    ++ "    jmp     MJ_L" ++ (show (label + 1)) ++ "\n"
    ++ "MJ_L" ++ (show label) ++ ":\n"
    ++ "    ldi     r"++show (reg+1)++", hi8(-1)\n"
    ++ "MJ_L" ++ (show (label + 1)) ++ ":\n\n"

promoteByteToInt :: AST -> Int -> String
promoteByteToInt operand label =
       "    #promote second operand byte to integer\n"
    ++ "    tst     r24\n"
    ++ "    brlt    MJ_L" ++ (show label) ++ "\n"
    ++ "    ldi     r25, 0\n"
    ++ "    jmp     MJ_L" ++ (show (label + 1)) ++ "\n"
    ++ "MJ_L" ++ (show label) ++ ":\n"
    ++ "    ldi     r25, hi8(-1)\n"
    ++ "MJ_L" ++ (show (label + 1)) ++ ":\n"

promoteByteToInt' :: AST -> Int -> String
promoteByteToInt' operand label =
       "    #promote first operand byte to integer\n"
    ++ "    tst     r18\n"
    ++ "    brlt    MJ_L" ++ (show label) ++ "\n"
    ++ "    ldi     r19, 0\n"
    ++ "    jmp     MJ_L" ++ (show (label + 1)) ++ "\n"
    ++ "MJ_L" ++ (show label) ++ ":\n"
    ++ "    ldi     r19, hi8(-1)\n"
    ++ "MJ_L" ++ (show (label + 1)) ++ ":\n"

setUpFunctionCall :: SymbolTable -> String
setUpFunctionCall st@(SymTab prog_scope [method_name,class_name]) = 
    let 
        --for each parameter pop the correct number of bytes into ascending registers
        (TS paramTypes ret_type) = lookupTypeSig st class_name method_name
        num_params = length paramTypes
        starting_register = (24) - (num_params * 2)
        params = functionLoadParams (reverse paramTypes) starting_register
        id = correctName (class_name ++ method_name)
        call_function = "\n    #receiver will be passed in as first param\n"
                     ++ "    pop r24\n"
                     ++ "    pop r25\n"
                     ++ "    call " ++ id ++ "\n"
    in
        if ret_type == IntType then
            (params ++ call_function ++ 
               "    #handles return value\n"
            ++ "    push r25\n"
            ++ "    push r24\n")
        else if ret_type == VoidType then 
            (params ++ call_function)
        else
            (params ++ call_function ++ 
               "    #handles return value\n"
            ++ "    push r24\n")

setUpFunctionCall st@(SymTab prog_scope [mname,method_name,class_name]) = 
    let 
        --for each parameter pop the correct number of bytes into ascending registers
        st1 = popScope st
        (TS paramTypes ret_type) = lookupTypeSig st1 class_name method_name
        num_params = length paramTypes
        starting_register = (24) - (num_params * 2)
        params = functionLoadParams (reverse paramTypes) starting_register
        call_function = "\n    #receiver will be passed in as first param\n"
                     ++ "    pop r24\n"
                     ++ "    pop r25\n"
                     ++ "    call " ++ class_name ++ method_name ++ "\n"
    in
        if ret_type == IntType then
            (params ++ call_function ++ 
               "    #handles return value\n"
            ++ "    push r25\n"
            ++ "    push r24\n")
        else if ret_type == VoidType then 
            (params ++ call_function)
        else
            (params ++ call_function ++ 
               "    #handles return value\n"
            ++ "    push r24\n")


setUpFunctionCall st = error (show st)

helpStoreMethodParams :: [(String, Type)] -> SymbolTable -> Int -> String
helpStoreMethodParams [] st reg = ""
helpStoreMethodParams ((pName,pType):rest) st reg
    | pType == IntType =
        let
            offsetH = lookupParamOffset st pName
            offsetL = offsetH-1
        in  "    std Y + "++show offsetH++", r"++show (reg+1)++"\n"
          ++"    std Y + "++show offsetL++", r"++show (reg)++"\n"
          ++helpStoreMethodParams rest st (reg-2)
    | otherwise =
        let
            offset = lookupParamOffset st pName
        in
            "    std Y + "++show offset++", r"++show reg++"\n"
          ++helpStoreMethodParams rest st (reg-2)

helpLoadMethodReturnValue :: Type -> String
helpLoadMethodReturnValue ret_type                  -- = to fix syntax hilighting.
    | ret_type == IntType = "    # load a two byte expression off stack\n"
                         ++ "    pop r24\n"
                         ++ "    pop r25\n"
    | ret_type == VoidType = "    # Nothing to return -> Void return type\n"
    | otherwise = "    # load a one byte expression off stack\n"
               ++ "    pop r24\n"

functionLoadParams :: [(String, Type)] -> Int-> String
functionLoadParams [] reg = ""
functionLoadParams ((pName, pType):rest) reg
    | pType == IntType =
        "    # load a two byte expression off stack\n"
     ++ "    pop r"++show reg++"\n"
     ++ "    pop r"++show (reg+1)++"\n"
     ++ functionLoadParams rest (reg+2)
    | otherwise =
        "    # load a one byte expression off stack\n"
     ++ "    pop r"++show reg++"\n"
     ++ functionLoadParams rest (reg+2)

-- A list of ASTs (parameters) and the symbol table and the method name and the current label number produce
--      -> The new label number and the code that represents the list of ASTs (parameters)
evaluateParams :: ([AST], SymbolTable) -> String -> Int -> (Int, String)
evaluateParams ([], st) method_name label = (label, "")
evaluateParams ((param@(Identifier id):rest), st) method_name label =
    let
        (label1, param_code)              = avrCodeGen (param, st) label
        (final_label, rest_of_param_code) = evaluateParams (rest, st) method_name label
    in
        (final_label, param_code ++ rest_of_param_code)

evaluateParams ((param:rest), st) method_name label =
    let
        st1 = popScope st
        (label1, param_code)              = avrCodeGen (param, st1) label
        (final_label, rest_of_param_code) = evaluateParams (rest, st1) method_name label
    in
        (final_label, param_code ++ rest_of_param_code)

numBytesInParameters :: [(String, Type)] -> Int -> Int 
numBytesInParameters [] num = num
numBytesInParameters ((_, IntType):rest) num = numBytesInParameters rest (num + 2)
numBytesInParameters ((_, _):rest) num = numBytesInParameters rest (num + 1)

correctName :: String -> String
correctName "" = ""
correctName (x:xs)
    | x == '$' = "Dolla" ++ correctName xs
    | x == '_' = "Underscore" ++ correctName xs
    | otherwise = x : correctName xs
