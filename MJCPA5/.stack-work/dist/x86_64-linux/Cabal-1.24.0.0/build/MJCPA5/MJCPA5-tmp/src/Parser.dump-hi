
==================== FINAL INTERFACE ====================
2016-12-02 01:16:50.414984225 UTC

interface main@main:Parser 8001
  interface hash: a4bfa110fc7faa7a3cb38710c2d7f893
  ABI hash: 117615ae5a33b3021f9299e5e575f2f8
  export-list hash: 8f36138a96c1bc5730de9fbae50ad4c1
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 6ea86ecbb747c8bfd1b624d46b10840a
  sig of: Nothing
  used TH splices: False
  where
exports:
  Parser.checkTokens
  Parser.first_Expression
  Parser.first_K
  Parser.first_L
  Parser.first_Type
  Parser.follow_E
  Parser.follow_F'
  Parser.follow_G'
  Parser.follow_H'
  Parser.follow_I'
  Parser.genAST
  Parser.grab_Type
  Parser.match
  Parser.parseA
  Parser.parseCD
  Parser.parseE
  Parser.parseE'
  Parser.parseF
  Parser.parseF'
  Parser.parseG
  Parser.parseG'
  Parser.parseH
  Parser.parseH'
  Parser.parseI
  Parser.parseI'
  Parser.parseInvoke
  Parser.parseJ
  Parser.parseK
  Parser.parseL
  Parser.parseMC
  Parser.parseMD
  Parser.parseP
  Parser.parseParam
  Parser.parseParamDecl
  Parser.parseProg
  Parser.parseSL
  Parser.parseSL'
  Parser.parseStm
  Parser.parseU
  Parser.parseV
  Parser.parseVD
  Parser.parseX
  Parser.parseY
  Parser.parseZ
module dependencies: Lexer Util
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  Lexer ba2bc94142bdc1c134083511bd0f019b
  exports: 85d7c38f12e022923f1a05eb06ba6a89
  Token a92d36fb480bd9ffd532ed906def93c4
  TokenAdd cf18ae40b8ff35d82a590c5cdb3b115c
  TokenAnd 1b1d70f441745a034fd8685b826725a7
  TokenBoolean 48a4c0db69b3f3e2f2c13d97562f726c
  TokenButtonValue 90637e21054b5d9465877e579ded7052
  TokenByte 7f34ecbf17c1c70333051ee6ae217ccc
  TokenByteCast 807460654ec622e687171bc7000dccc2
  TokenClass e7192e046e3fced4e9e76b447510805a
  TokenColor bb149da5942f69df86b8091df29a2148
  TokenColorArrayType 5dbff86423780f2717631dae01df418b
  TokenColorValue 370707c23a8c1fff5cc4738fd59d0920
  TokenComma a193c0eb01de5a68f487e030ed24ab3d
  TokenDot 6dba61d97dc1eb22ef8fd02f57d81a9c
  TokenEOF 88e21709ad1881f13a09ba79fe08ec43
  TokenElse 3eb455fa58ee2b542d261f3657a5d412
  TokenEquality fe40ba70fcbf109216e9cc821dfee27a
  TokenFalse 9815f78ae4c0d8f4f38447a7a10cd698
  TokenID f8ea9d53e7c7e259e34dbcddd6dcdd41
  TokenIf 924a5339eeb5e6b00490c4cf0a437dd9
  TokenInt 3441a77e46378a411ba32217a5506f67
  TokenIntArrayType eada29c5fcd6f5199ab6aa1952c0b4a4
  TokenLeftBracket 55abb399e6f5cda561297f12ff21ee46
  TokenLeftCurly 296817db0b795773a927374df7aeb359
  TokenLeftParen 7d80a2d03697fba4c12149f8b9770a7e
  TokenLessThan 1ad35aff49934eeadb1077aea1c46860
  TokenMain 1a4ea544484313e9d2f30e3a6236b23b
  TokenMeggyButton df5bd9293b42ef2eef4ffaca74af83f4
  TokenMeggyButtonType 4e0102e186110d98a8f9771933d38eaa
  TokenMeggyCheckButton 0868d3d38c0f2d81a470daba17607270
  TokenMeggyColor 1b2b9f2092a08ce9f5c5446352f374b4
  TokenMeggyColorType 76b65404b0e32f066a7a98492756f866
  TokenMeggyDelay 6e818727a9d2694f88a3b1807547808f
  TokenMeggyGetPix 729e77d0b4855070e6ae562a54c1aee3
  TokenMeggyImport b9b1e23381f2dc8faa543ee79cfbc19a
  TokenMeggySetPix 0e1a60170759d408e31defbd553b0afe
  TokenMeggyTone cabc5fee56bb0077c0184559640ec811
  TokenMeggyToneStart 98a78db7fa357eaaec8319db97a2f238
  TokenMeggyToneType 241e0a5cbcdfd2355b07803405d1657f
  TokenMul 8ddd4015fbfbdfee556c923e89cf7a0b
  TokenNew 6bdafb20c146d34037ea6cc2b7811bba
  TokenNot 9cacaf2e3df9e4e4edfb56b9cdd75d13
  TokenNum c9284e3e918811c157ef09a4badbb24f
  TokenPublic cc3d42e155bd6027089b4da5aa04dacb
  TokenReturn bba283d2fe7cea0692c6f99ccd2e9d0c
  TokenRightBracket 7a1d485ba276d8466705ad19ca8b3dd7
  TokenRightCurly 99078300a0dfa2bf829c5225723648ca
  TokenRightParen 421d149ba1a8b5cb6a6dda01e128c856
  TokenSemiColon 94cc2576687f4c99edf0aca1c29cb1a9
  TokenStatic fe0b7bf7615138060a37fdd782dd8233
  TokenString d5464ca0b973af707fab0875a02cb45e
  TokenSub ea7dff3467dba4afe0b3fc8fa694198e
  TokenThis ef713f0c3ae48ae332836bd82bee7930
  TokenToneValue f8d583cda65e5238551ece064c203166
  TokenTrue 1e3c5bfa7881808f0dbc32361f28c9f1
  TokenVoid c06305f856b46d5e6cd1448d7568499a
  TokenWhile 65a8c6fa94a996ea8217d6733d8b180b
  UnexpectedEOF 9c6d09aabf6b06a680d644ad1fb9dda5
import  -/  Util 584e30b3c8003828425244522b124edd
  exports: 6ebad5c4a934f78d2a8da097b4f64c2d
  AST 88b1d8d104bedf4e10abe56758f4c48a
  Add db81475a2c126d7c611d0f8b2e4f7f52
  Body d153fc4cffa24358844f2c9d3923ca5d
  Boolean e739b86a037718e2330f9cdaaafce984
  BooleanType 661eea5c4b454ea3ccf4a04e40879c26
  ButtonLiteral 4ad405580f89d5ea0c4b62a058c49b6a
  ByteCast cb6fb553e8a5070eabaff85fc6f90aba
  ByteType 2dbfbae615c60d81b613b3a7182ee089
  CheckButton 53ed53cdc30dd0aa807c1a76fb02f9f6
  Class a29d9e4aa2277ed1177c891a7d9c6fa2
  ColorArrayInstance 654b1165242232670ae823c5716bff16
  ColorArrayType f5a02761ecf6ff782008d0e9b4b7a94f
  ColorLiteral a09646b113ce60663aec427bcb52f846
  Delay 5b82435487e812bf6960759028ebb880
  Epsilon 0e2368b12583e00d4e901fa8122311bd
  GetPixel 208060c1089d54665dccfbbb8d583336
  Identifier f478eb751275069f15e7e4de47d2d2da
  If e27db102bf0056b79af21adde1bf36ce
  Instance 1f8b789ceb1dc9c8b52369069df392c1
  IntArrayInstance 09dd4ca0ae569aa29e841aff794cbfbf
  IntArrayType 94fa9ac378756e4f357d4b585dc400a7
  IntLiteral 144ca1c2ffe233b0c950c624e8c02dcb
  IntType f24052e5e6d03b5090f1567cdf154497
  Invoke 394424b76f631cbc504d27941f93f06d
  LessThan 04de00e6959fa80e021133802ba7d0a3
  LogicalAnd f1b595ca577ba5d451a0424a7ce6f3c7
  LogicalEqual ca207935a5bed546edc0c82892c1b286
  LogicalNot f72502ca7b096bc637bacc2d6d74d751
  MainClass c643e2cf340b183c486690155e63d5b6
  MeggyButtonType 6ff0ae99e7fe6491ef79c0a62e153f7f
  MeggyColorType 73f19f4b58afeeb85f71476c58ea1009
  MeggyToneType 5b7ccae6bfc86776e91c142a0625023e
  Method e89e84b8d9a0031f06f1abb3017f45ad
  Mul 732a40472d91b8d45034e578d3314e1f
  ParenExp 86473db8b42f2e0d4008971bbffc96bb
  Prog 05b8d730c89ff5259eebdd22d173c52a
  Return c9835deb9c6b930c6065b5d2934971ae
  SetPixel 5c654e2487eb0cc6617806266d24b80d
  Sub e11a71115abf5a41f92f1cadd41f310a
  TS 17e2bdd4b8adc4f87694194faae61e6b
  ToneLiteral 808f067228df16294222666189597a3a
  ToneStart fc7760204e63c5e8b6673dfbf71619c0
  Type b11fd09e544b732e5075f4cb20dd6d55
  UnaryMinus 6ddef5ed6239e224ccba8881f3a776f9
  Variable 7cf625bd6bdccb494cae9d480eb3c408
  VoidType bb628c644700193b80f763345c48d96e
  While 89f69faf2123b482645b8da033ba9438
f0a0f59f5f25fe61cacd5ca0b1e46baa
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Parser.$trModule2
                   Parser.$trModule1) -}
3bb112fe95a6a1ba67f7413689a4712f
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Parser"#) -}
9ac4f0eece8cebd95bd00f913c45b738
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
0811e74b847bef36762697d26f9904e0
  $wparseA ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
d40537776c23283f2632d5c6243cd4dc
  $wparseE ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
3e15b1cf9f5ff4202a38afb822cb47d9
  $wparseE' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
54c9e08d2b2d2dde806f0116296b4c12
  $wparseF ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
759d45a3600a0f8d1ad29837333d6ad6
  $wparseF' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
1df2aa2a7a92d0e318d67c0b6133d016
  $wparseG ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
304dc945b90896daed98c56c032977d8
  $wparseG' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
d4caa4ea2c2640a64b0bf9a77d82f037
  $wparseH ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
c13851525c60a9a7f9b73dfb326bb36d
  $wparseH' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
80cccb7fc182ef84269be5e3d6131fa4
  $wparseI ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
0fe5f7f85762fea928d2b401df4d7443
  $wparseI' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
7e228c231363ecde16602d336e152785
  $wparseInvoke ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [(Lexer.Token,
                           (GHC.Types.Int, GHC.Types.Int))]) ->
                 case w of wild {
                   []
                   -> case Parser.parseInvoke1
                      ret_ty (# Util.AST,
                                [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                      of {}
                   : ds rest
                   -> case ds of wild1 { (,) ds1 ds2 ->
                      case ds1 of wild2 {
                        DEFAULT
                        -> case Parser.parseInvoke1
                           ret_ty (# Util.AST,
                                     [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                           of {}
                        Lexer.TokenID id
                        -> case ds2 of wild3 { (,) row col ->
                           let {
                             ds3 :: ([Util.AST],
                                     [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                             = case Parser.$wparseParam
                                      (Parser.match
                                         rest
                                         Lexer.TokenLeftParen) of ww { (#,#) ww1 ww2 ->
                               (ww1, ww2) }
                           } in
                           (# Util.Invoke (case ds3 of wild4 { (,) params ts2 -> params }) id,
                              case ds3 of wild4 { (,) params ts2 -> ts2 } #) } } } }) -}
f915a019229d964aa5d17881e8c54d03
  $wparseJ ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
1b635429e7f850711737c818609c768e
  $wparseK ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
43947a4772f9d3f8fa06ed06fe1a8862
  $wparseL ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
c0ac264feb17ab0d9ebb89c89d2699e4
  $wparseMC ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [(Lexer.Token,
                           (GHC.Types.Int, GHC.Types.Int))]) ->
                 case w of wild {
                   []
                   -> case Parser.genAST2
                      ret_ty (# Util.AST,
                                [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                      of {}
                   : ds ds1
                   -> case ds of wild1 { (,) ds2 ds3 ->
                      case ds2 of wild2 {
                        DEFAULT
                        -> case Parser.genAST2
                           ret_ty (# Util.AST,
                                     [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                           of {}
                        Lexer.TokenClass
                        -> case ds3 of wild3 { (,) row col ->
                           case ds1 of wild4 {
                             []
                             -> case Parser.genAST2
                                ret_ty (# Util.AST,
                                          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                of {}
                             : ds4 rest
                             -> case ds4 of wild5 { (,) ds5 ds6 ->
                                case ds5 of wild6 {
                                  DEFAULT
                                  -> case Parser.genAST2
                                     ret_ty (# Util.AST,
                                               [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                     of {}
                                  Lexer.TokenID class_name
                                  -> case ds6 of wild7 { (,) row1 col1 ->
                                     let {
                                       ds7 :: ([Util.AST],
                                               [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                                       = case Parser.match
                                                (Parser.match
                                                   (Parser.match
                                                      (Parser.match
                                                         (Parser.match
                                                            (Parser.match
                                                               (Parser.match
                                                                  (Parser.match
                                                                     (Parser.match
                                                                        rest
                                                                        Lexer.TokenLeftCurly)
                                                                     Lexer.TokenPublic)
                                                                  Lexer.TokenStatic)
                                                               Lexer.TokenVoid)
                                                            Lexer.TokenMain)
                                                         Lexer.TokenLeftParen)
                                                      Lexer.TokenString)
                                                   Lexer.TokenLeftBracket)
                                                Lexer.TokenRightBracket of wild8 {
                                           []
                                           -> case Parser.genAST1
                                              ret_ty ([Util.AST],
                                                      [(Lexer.Token,
                                                        (GHC.Types.Int, GHC.Types.Int))])
                                              of {}
                                           : argsname ts8
                                           -> case Parser.$wparseSL'
                                                     (Parser.match
                                                        (Parser.match ts8 Lexer.TokenRightParen)
                                                        Lexer.TokenLeftCurly) of ww { (#,#) ww1 ww2 ->
                                              (ww1, ww2) } }
                                     } in
                                     (# Util.MainClass
                                          (Util.Body
                                             (case ds7 of wild8 { (,) sl remainingTokens -> sl })),
                                        case ds7 of wild8 { (,) sl remainingTokens ->
                                        Parser.match
                                          (Parser.match remainingTokens Lexer.TokenRightCurly)
                                          Lexer.TokenRightCurly } #) } } } } } } } }) -}
00b794224438b1c1cdbb4a952fa6ca39
  $wparseMD ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# [Util.AST],
          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
47d07803b2e82602bdd3b0df80f99501
  $wparseP ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [(Lexer.Token,
                           (GHC.Types.Int, GHC.Types.Int))]) ->
                 case w of wild {
                   []
                   -> case Parser.parseP1
                      ret_ty (# Util.AST,
                                [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                      of {}
                   : ds ds1
                   -> case ds of wild1 { (,) ds2 ds3 ->
                      case ds2 of wild2 {
                        DEFAULT
                        -> case Parser.parseP1
                           ret_ty (# Util.AST,
                                     [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                           of {}
                        Lexer.TokenColor
                        -> case ds3 of wild3 { (,) r1 c1 ->
                           case ds1 of wild4 {
                             []
                             -> case Parser.parseP1
                                ret_ty (# Util.AST,
                                          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                of {}
                             : ds4 rest
                             -> case ds4 of wild5 { (,) ds5 ds6 ->
                                case ds5 of wild6 {
                                  DEFAULT
                                  -> case Parser.parseP1
                                     ret_ty (# Util.AST,
                                               [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                     of {}
                                  Lexer.TokenLeftBracket
                                  -> case ds6 of wild7 { (,) r2 c2 ->
                                     let {
                                       ds7 :: (Util.AST,
                                               [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                                       = case Parser.$wparseE rest of ww { (#,#) ww1 ww2 ->
                                         (ww1, ww2) }
                                     } in
                                     (# Util.ColorArrayInstance
                                          (case ds7 of wild8 { (,) capacity ts1 -> capacity }),
                                        case ds7 of wild8 { (,) capacity ts1 ->
                                        Parser.match ts1 Lexer.TokenRightBracket } #) } } } } }
                        Lexer.TokenID id
                        -> case ds3 of wild3 { (,) r1 c1 ->
                           case ds1 of wild4 {
                             []
                             -> case Parser.parseP1
                                ret_ty (# Util.AST,
                                          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                of {}
                             : ds4 ds5
                             -> case ds4 of wild5 { (,) ds6 ds7 ->
                                case ds6 of wild6 {
                                  DEFAULT
                                  -> case Parser.parseP1
                                     ret_ty (# Util.AST,
                                               [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                     of {}
                                  Lexer.TokenLeftParen
                                  -> case ds7 of wild7 { (,) r2 c2 ->
                                     case ds5 of wild8 {
                                       []
                                       -> case Parser.parseP1
                                          ret_ty (# Util.AST,
                                                    [(Lexer.Token,
                                                      (GHC.Types.Int, GHC.Types.Int))] #)
                                          of {}
                                       : ds8 rest
                                       -> case ds8 of wild9 { (,) ds9 ds10 ->
                                          case ds9 of wild10 {
                                            DEFAULT
                                            -> case Parser.parseP1
                                               ret_ty (# Util.AST,
                                                         [(Lexer.Token,
                                                           (GHC.Types.Int, GHC.Types.Int))] #)
                                               of {}
                                            Lexer.TokenRightParen
                                            -> case ds10 of wild11 { (,) r3 c3 ->
                                               let {
                                                 ds11 :: (Util.AST,
                                                          [(Lexer.Token,
                                                            (GHC.Types.Int, GHC.Types.Int))])
                                                 = case Parser.$wparseL
                                                          rest of ww { (#,#) ww1 ww2 ->
                                                   (ww1, ww2) }
                                               } in
                                               (# Util.Instance
                                                    (case ds11 of wild12 { (,) invocation ts1 ->
                                                     invocation })
                                                    id,
                                                  case ds11 of wild12 { (,) invocation ts1 ->
                                                  ts1 } #) } } } } } } } } }
                        Lexer.TokenInt
                        -> case ds3 of wild3 { (,) r1 c1 ->
                           case ds1 of wild4 {
                             []
                             -> case Parser.parseP1
                                ret_ty (# Util.AST,
                                          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                of {}
                             : ds4 rest
                             -> case ds4 of wild5 { (,) ds5 ds6 ->
                                case ds5 of wild6 {
                                  DEFAULT
                                  -> case Parser.parseP1
                                     ret_ty (# Util.AST,
                                               [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
                                     of {}
                                  Lexer.TokenLeftBracket
                                  -> case ds6 of wild7 { (,) r2 c2 ->
                                     let {
                                       ds7 :: (Util.AST,
                                               [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                                       = case Parser.$wparseE rest of ww { (#,#) ww1 ww2 ->
                                         (ww1, ww2) }
                                     } in
                                     (# Util.IntArrayInstance
                                          (case ds7 of wild8 { (,) capacity ts1 -> capacity }),
                                        case ds7 of wild8 { (,) capacity ts1 ->
                                        Parser.match
                                          ts1
                                          Lexer.TokenRightBracket } #) } } } } } } } }) -}
ea18499a1d34df982bbc8d7886f7a308
  $wparseParam ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# [Util.AST],
          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
581d30ab8168121ecdce37d2502eb0f2
  $wparseParamDecl ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# [(GHC.Base.String, Util.Type)],
          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
02d70571cb5dc7d00e4bb71d93654f8c
  $wparseSL' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# [Util.AST],
          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
257a4c0283fd466268b5eec6e8036ab9
  $wparseStm ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
5dc257bb64213dfe1f0639512418ff46
  $wparseV ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# [(GHC.Base.String, Util.Type)],
          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
fa2c4a625c985749851f57110231109b
  $wparseY ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# [Util.AST],
          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
dd310baac9eabe8dcbd20c2c9f1487b1
  $wparseZ ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (# Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
e1e26288900c9d2362fd0a08b05e9e21
  checkTokens ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
6b13ea33d3cc7275d7d8a1ec5d00476f
  first_Expression :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 case t of wild {
                   DEFAULT -> GHC.Types.False
                   Lexer.TokenDot -> GHC.Types.True
                   Lexer.TokenLeftParen -> GHC.Types.True
                   Lexer.TokenID ds -> GHC.Types.True
                   Lexer.TokenNum ds -> GHC.Types.True
                   Lexer.TokenSub -> GHC.Types.True
                   Lexer.TokenNot -> GHC.Types.True
                   Lexer.TokenTrue -> GHC.Types.True
                   Lexer.TokenFalse -> GHC.Types.True
                   Lexer.TokenThis -> GHC.Types.True
                   Lexer.TokenNew -> GHC.Types.True
                   Lexer.TokenMeggyGetPix -> GHC.Types.True
                   Lexer.TokenMeggyCheckButton -> GHC.Types.True
                   Lexer.TokenMeggyTone -> GHC.Types.True
                   Lexer.TokenMeggyColor -> GHC.Types.True
                   Lexer.TokenMeggyButton -> GHC.Types.True
                   Lexer.TokenByteCast -> GHC.Types.True }) -}
ff81b7ccbe6d0d105639aca89cfa05fb
  first_K :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 case t of wild {
                   DEFAULT -> GHC.Types.False
                   Lexer.TokenDot -> GHC.Types.True
                   Lexer.TokenLeftParen -> GHC.Types.True
                   Lexer.TokenID ds -> GHC.Types.True
                   Lexer.TokenNum ds -> GHC.Types.True
                   Lexer.TokenSub -> GHC.Types.True
                   Lexer.TokenNot -> GHC.Types.True
                   Lexer.TokenTrue -> GHC.Types.True
                   Lexer.TokenFalse -> GHC.Types.True
                   Lexer.TokenThis -> GHC.Types.True
                   Lexer.TokenMeggyGetPix -> GHC.Types.True
                   Lexer.TokenMeggyCheckButton -> GHC.Types.True
                   Lexer.TokenMeggyTone -> GHC.Types.True
                   Lexer.TokenMeggyColor -> GHC.Types.True
                   Lexer.TokenMeggyButton -> GHC.Types.True }) -}
b2ba7012453fd15478ff8d25bab881a8
  first_L :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 case t of wild {
                   DEFAULT -> GHC.Types.False
                   Lexer.TokenDot -> GHC.Types.True
                   Lexer.TokenLeftParen -> GHC.Types.True
                   Lexer.TokenID ds -> GHC.Types.True
                   Lexer.TokenNum ds -> GHC.Types.True
                   Lexer.TokenTrue -> GHC.Types.True
                   Lexer.TokenFalse -> GHC.Types.True
                   Lexer.TokenThis -> GHC.Types.True
                   Lexer.TokenMeggyGetPix -> GHC.Types.True
                   Lexer.TokenMeggyCheckButton -> GHC.Types.True
                   Lexer.TokenMeggyTone -> GHC.Types.True
                   Lexer.TokenMeggyColor -> GHC.Types.True
                   Lexer.TokenMeggyButton -> GHC.Types.True }) -}
c634dc4cb9c57af0db14a997b912561c
  first_Type :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 case t of wild {
                   DEFAULT -> GHC.Types.False
                   Lexer.TokenVoid -> GHC.Types.True
                   Lexer.TokenByte -> GHC.Types.True
                   Lexer.TokenInt -> GHC.Types.True
                   Lexer.TokenBoolean -> GHC.Types.True
                   Lexer.TokenMeggyColorType -> GHC.Types.True
                   Lexer.TokenMeggyButtonType -> GHC.Types.True
                   Lexer.TokenMeggyToneType -> GHC.Types.True
                   Lexer.TokenIntArrayType -> GHC.Types.True
                   Lexer.TokenColorArrayType -> GHC.Types.True }) -}
c8fdcf4893093de87cd64ca725ca18de
  follow_E :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (t :: Lexer.Token) ->
                 case t of wild {
                   DEFAULT -> GHC.Types.False
                   Lexer.TokenDot -> GHC.Types.True
                   Lexer.TokenRightBracket -> GHC.Types.True
                   Lexer.TokenRightParen -> GHC.Types.True
                   Lexer.TokenComma -> GHC.Types.True
                   Lexer.TokenSemiColon -> GHC.Types.True }) -}
546fc268b7b98722dc3d46adaf28c939
  follow_F' :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 case t of wild {
                   DEFAULT
                   -> case GHC.Prim.dataToTag# @ Lexer.Token wild of wild1 {
                        DEFAULT -> GHC.Types.False 36# -> GHC.Types.True }
                   Lexer.TokenDot -> GHC.Types.True
                   Lexer.TokenRightBracket -> GHC.Types.True
                   Lexer.TokenRightParen -> GHC.Types.True
                   Lexer.TokenComma -> GHC.Types.True
                   Lexer.TokenSemiColon -> GHC.Types.True
                   Lexer.TokenColorValue a1 -> GHC.Types.False
                   Lexer.TokenButtonValue a1 -> GHC.Types.False
                   Lexer.TokenID a1 -> GHC.Types.False
                   Lexer.TokenNum a1 -> GHC.Types.False
                   Lexer.TokenToneValue a1 -> GHC.Types.False
                   Lexer.UnexpectedEOF a1 -> GHC.Types.False
                   Lexer.TokenUnknown a1 -> GHC.Types.False }) -}
65cd285da96ceb1f3d2019d573de4a56
  follow_G' :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     case t of wild {
                       DEFAULT
                       -> case GHC.Prim.dataToTag# @ Lexer.Token wild of wild1 {
                            DEFAULT -> GHC.Types.False 37# -> GHC.Types.True }
                       Lexer.TokenColorValue a1 -> GHC.Types.False
                       Lexer.TokenButtonValue a1 -> GHC.Types.False
                       Lexer.TokenID a1 -> GHC.Types.False
                       Lexer.TokenNum a1 -> GHC.Types.False
                       Lexer.TokenToneValue a1 -> GHC.Types.False
                       Lexer.UnexpectedEOF a1 -> GHC.Types.False
                       Lexer.TokenUnknown a1 -> GHC.Types.False }
                 } in
                 case t of wild {
                   DEFAULT
                   -> case GHC.Prim.dataToTag# @ Lexer.Token wild of wild1 {
                        DEFAULT -> $j GHC.Prim.void# 36# -> GHC.Types.True }
                   Lexer.TokenDot -> GHC.Types.True
                   Lexer.TokenRightBracket -> GHC.Types.True
                   Lexer.TokenRightParen -> GHC.Types.True
                   Lexer.TokenComma -> GHC.Types.True
                   Lexer.TokenSemiColon -> GHC.Types.True
                   Lexer.TokenColorValue a1 -> $j GHC.Prim.void#
                   Lexer.TokenButtonValue a1 -> $j GHC.Prim.void#
                   Lexer.TokenID a1 -> $j GHC.Prim.void#
                   Lexer.TokenNum a1 -> $j GHC.Prim.void#
                   Lexer.TokenToneValue a1 -> $j GHC.Prim.void#
                   Lexer.UnexpectedEOF a1 -> $j GHC.Prim.void#
                   Lexer.TokenUnknown a1 -> $j GHC.Prim.void# }) -}
78b3b297bdff2bfbefffcb0f4555db6a
  follow_H' :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Void# -> GHC.Types.Bool
                         {- Arity: 1, Strictness: <L,A> -}
                       = \ (w1 :: GHC.Prim.Void#)[OneShot] ->
                         case t of wild {
                           DEFAULT
                           -> case GHC.Prim.dataToTag# @ Lexer.Token wild of wild1 {
                                DEFAULT -> GHC.Types.False 46# -> GHC.Types.True }
                           Lexer.TokenColorValue a1 -> GHC.Types.False
                           Lexer.TokenButtonValue a1 -> GHC.Types.False
                           Lexer.TokenID a1 -> GHC.Types.False
                           Lexer.TokenNum a1 -> GHC.Types.False
                           Lexer.TokenToneValue a1 -> GHC.Types.False
                           Lexer.UnexpectedEOF a1 -> GHC.Types.False
                           Lexer.TokenUnknown a1 -> GHC.Types.False }
                     } in
                     case t of wild {
                       DEFAULT
                       -> case GHC.Prim.dataToTag# @ Lexer.Token wild of wild1 {
                            DEFAULT -> $j1 GHC.Prim.void# 37# -> GHC.Types.True }
                       Lexer.TokenColorValue a1 -> $j1 GHC.Prim.void#
                       Lexer.TokenButtonValue a1 -> $j1 GHC.Prim.void#
                       Lexer.TokenID a1 -> $j1 GHC.Prim.void#
                       Lexer.TokenNum a1 -> $j1 GHC.Prim.void#
                       Lexer.TokenToneValue a1 -> $j1 GHC.Prim.void#
                       Lexer.UnexpectedEOF a1 -> $j1 GHC.Prim.void#
                       Lexer.TokenUnknown a1 -> $j1 GHC.Prim.void# }
                 } in
                 case t of wild {
                   DEFAULT
                   -> case GHC.Prim.dataToTag# @ Lexer.Token wild of wild1 {
                        DEFAULT -> $j GHC.Prim.void# 36# -> GHC.Types.True }
                   Lexer.TokenDot -> GHC.Types.True
                   Lexer.TokenRightBracket -> GHC.Types.True
                   Lexer.TokenRightParen -> GHC.Types.True
                   Lexer.TokenComma -> GHC.Types.True
                   Lexer.TokenSemiColon -> GHC.Types.True
                   Lexer.TokenColorValue a1 -> $j GHC.Prim.void#
                   Lexer.TokenButtonValue a1 -> $j GHC.Prim.void#
                   Lexer.TokenID a1 -> $j GHC.Prim.void#
                   Lexer.TokenNum a1 -> $j GHC.Prim.void#
                   Lexer.TokenToneValue a1 -> $j GHC.Prim.void#
                   Lexer.UnexpectedEOF a1 -> $j GHC.Prim.void#
                   Lexer.TokenUnknown a1 -> $j GHC.Prim.void# }) -}
d056ec19a667f0c04e431b5d178cc034
  follow_I' :: Lexer.Token -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 case Parser.follow_H' t of wild {
                   GHC.Types.False
                   -> let {
                        $j :: GHC.Prim.Void# -> GHC.Types.Bool
                          {- Arity: 1, Strictness: <L,A> -}
                        = \ (w :: GHC.Prim.Void#)[OneShot] ->
                          case t of wild1 {
                            DEFAULT
                            -> case GHC.Prim.dataToTag# @ Lexer.Token wild1 of wild2 {
                                 DEFAULT -> GHC.Types.False 33# -> GHC.Types.True }
                            Lexer.TokenColorValue a1 -> GHC.Types.False
                            Lexer.TokenButtonValue a1 -> GHC.Types.False
                            Lexer.TokenID a1 -> GHC.Types.False
                            Lexer.TokenNum a1 -> GHC.Types.False
                            Lexer.TokenToneValue a1 -> GHC.Types.False
                            Lexer.UnexpectedEOF a1 -> GHC.Types.False
                            Lexer.TokenUnknown a1 -> GHC.Types.False }
                      } in
                      case t of wild1 {
                        DEFAULT
                        -> case GHC.Prim.dataToTag# @ Lexer.Token wild1 of wild2 {
                             DEFAULT -> $j GHC.Prim.void# 34# -> GHC.Types.True }
                        Lexer.TokenColorValue a1 -> $j GHC.Prim.void#
                        Lexer.TokenButtonValue a1 -> $j GHC.Prim.void#
                        Lexer.TokenID a1 -> $j GHC.Prim.void#
                        Lexer.TokenNum a1 -> $j GHC.Prim.void#
                        Lexer.TokenToneValue a1 -> $j GHC.Prim.void#
                        Lexer.UnexpectedEOF a1 -> $j GHC.Prim.void#
                        Lexer.TokenUnknown a1 -> $j GHC.Prim.void# }
                   GHC.Types.True -> GHC.Types.True }) -}
65fff3d3e14859e5ad3d9b59ace9b037
  genAST ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] -> Util.AST
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [(Lexer.Token,
                            (GHC.Types.Int, GHC.Types.Int))]) ->
                 case ds of wild {
                   [] -> Parser.genAST3
                   : ds1 rest
                   -> case ds1 of wild1 { (,) t ds2 ->
                      case ds2 of wild2 { (,) row col ->
                      case Parser.checkTokens wild of wild3 {
                        GHC.Types.False -> Util.Epsilon
                        GHC.Types.True
                        -> let {
                             ds3 :: (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                             = case Parser.$wparseMC
                                      (Parser.match
                                         wild
                                         Lexer.TokenMeggyImport) of ww { (#,#) ww1 ww2 ->
                               (ww1, ww2) }
                           } in
                           Util.Prog
                             (case ds3 of wild4 { (,) main_class ts2 -> main_class })
                             (case ds3 of wild4 { (,) main_class ts2 ->
                              Parser.parseCD ts2 }) } } } }) -}
e2eb43bacdef642b54d41d421f7643c3
  genAST1 ::
    ((Lexer.Token, (GHC.Types.Int, GHC.Types.Int)),
     [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Strictness: x -}
35c97e54f95be56a3deb7876049ae28f
  genAST2 ::
    (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Strictness: x -}
9fd7329104453b1b4c291485285dfe8f
  genAST3 :: Util.AST
  {- Strictness: x -}
e35f4ea769b03666b34efa951231a3b2
  grab_Type :: Lexer.Token -> Util.Type
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (t :: Lexer.Token) ->
                 case t of wild {
                   DEFAULT -> Parser.grab_Type1 wild
                   Lexer.TokenVoid -> Util.VoidType
                   Lexer.TokenByte -> Util.ByteType
                   Lexer.TokenInt -> Util.IntType
                   Lexer.TokenBoolean -> Util.BooleanType
                   Lexer.TokenMeggyColorType -> Util.MeggyColorType
                   Lexer.TokenMeggyButtonType -> Util.MeggyButtonType
                   Lexer.TokenMeggyToneType -> Util.MeggyToneType
                   Lexer.TokenIntArrayType -> Util.IntArrayType
                   Lexer.TokenColorArrayType -> Util.ColorArrayType }) -}
df75752250fd1ab2db8e16e86508d49a
  grab_Type1 :: Lexer.Token -> Util.Type
  {- Arity: 1, Strictness: <L,U>x -}
7b4909b23174c6d495c1dab5d8ef5f23
  match ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Lexer.Token -> [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (ds :: [(Lexer.Token,
                            (GHC.Types.Int, GHC.Types.Int))])
                   (expected :: Lexer.Token) ->
                 case ds of wild {
                   [] -> Parser.match3
                   : ds1 rest
                   -> case ds1 of wild1 { (,) given ds2 ->
                      case ds2 of wild2 { (,) row col ->
                      case Lexer.$fEqToken_$c== given expected of wild3 {
                        GHC.Types.False -> Parser.match1 given expected col row
                        GHC.Types.True -> rest } } } }) -}
bbdd18c400b7ae340ee9fc1ef9241814
  match1 ::
    Lexer.Token
    -> Lexer.Token
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
  {- Arity: 4, Strictness: <B,1*U><B,1*U><B,1*U(U)><B,1*U(U)>x,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: Lexer.Token)
                   (w1 :: Lexer.Token)
                   (w2 :: GHC.Types.Int)
                   (w3 :: GHC.Types.Int) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { GHC.Types.I# ww3 ->
                 Parser.match2 w w1 ww1 ww3 } }) -}
c12560d022f53498e9c77212f0f4cbbd
  match2 ::
    Lexer.Token
    -> Lexer.Token
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>x -}
8b1c80b9cac4822253df2118e35726f8
  match3 :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
  {- Strictness: x -}
16e313c0b96f009a05ba157d7e6390d4
  parseA ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseA w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
0ff89e3bd26ee19cb30da109da5a5979
  parseCD ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] -> [Util.AST]
  {- Arity: 1, Strictness: <S,1*U> -}
fad8a59db4bb8a407665527597841c24
  parseE ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseE w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
72c3ac89ddc19acd717ddbf37f07d3a5
  parseE' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   (w1 :: Util.AST) ->
                 case Parser.$wparseE' w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
4c5d1a0c5c0503d3947ff30e687b11bd
  parseF ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseF w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
d535cdbe5df299bd1d13901b7cc2f4df
  parseF' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   (w1 :: Util.AST) ->
                 case Parser.$wparseF' w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
4fd60f259d412e12cc3517916ce5f95f
  parseG ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseG w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
258b792e8cc1ac0a0719b34fcac8002a
  parseG' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   (w1 :: Util.AST) ->
                 case Parser.$wparseG' w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
5d29068acb16ef856f6598ae5ca6018b
  parseH ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseH w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
1be8d6fef866af61b3d3ea1a5675138d
  parseH' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   (w1 :: Util.AST) ->
                 case Parser.$wparseH' w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
0e3dda1d4554220456176a30a9700998
  parseI ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseI w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
196113d7eddb6b191bd5654e188bd284
  parseI' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> Util.AST
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   (w1 :: Util.AST) ->
                 case Parser.$wparseI' w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
d7af59ab8092ba6f252d2de924b46b3b
  parseInvoke ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseInvoke w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
f16bffa15c0e33cf354c5b70da3e2fd0
  parseInvoke1 ::
    (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Strictness: x -}
bfab2442c4da5e1425fd760d82271d41
  parseJ ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseJ w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
c4e71717f8c84fe8e0086c0fff496716
  parseK ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseK w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
acb357bb0f7b97ed60ce7b0165ff418c
  parseL ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseL w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
373d62861d7df2ff80906f42b4115249
  parseMC ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseMC w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
4741e8f21ddd31d34c3e0f36c2fd22f2
  parseMD ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> ([Util.AST], [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseMD w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
d9164e273741436b63ca60b90b3a117b
  parseP ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseP w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
ad9fd1a9c9c719fa08a18a87cd606b5e
  parseP1 ::
    (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Strictness: x -}
814a1269bc0c805557b7cc6a5658f9ad
  parseParam ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> ([Util.AST], [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseParam w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
ba076ae4d1cd6a4b7cbfe37539e3efe2
  parseParamDecl ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> ([(GHC.Base.String, Util.Type)],
        [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseParamDecl w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
28d02915208b4f5ac9f9395b97ae071f
  parseProg ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))] -> Util.AST
  {- Arity: 1, Strictness: <L,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 let {
                   ds :: (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   = case Parser.$wparseMC
                            (Parser.match w Lexer.TokenMeggyImport) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 Util.Prog
                   (case ds of wild { (,) main_class ts2 -> main_class })
                   (case ds of wild { (,) main_class ts2 -> Parser.parseCD ts2 })) -}
6ac0085e5748a43be981a4433bcc96a7
  parseSL ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <L,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (tokenList :: [(Lexer.Token,
                                   (GHC.Types.Int, GHC.Types.Int))]) ->
                 let {
                   ds :: ([Util.AST], [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   = Parser.parseSL' tokenList
                 } in
                 (Util.Body (case ds of wild { (,) sl remainingTokens -> sl }),
                  case ds of wild { (,) sl remainingTokens -> remainingTokens })) -}
623f6f91523382ad86ee86979ad2d2fb
  parseSL' ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> ([Util.AST], [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseSL' w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
20a703ac500de5cc95a52c943bd179b8
  parseStm ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseStm w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
39b02b68e11fcd14876a5d34593b9bd0
  parseU ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> ((GHC.Base.String, Util.Type),
        [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case w of wild {
                   [] -> Parser.parseU3
                   : ds ds1
                   -> case ds of wild1 { (,) typeTok ds2 ->
                      case ds2 of wild2 { (,) row col ->
                      case ds1 of wild3 {
                        []
                        -> case col of ww { GHC.Types.I# ww1 ->
                           case row of ww2 { GHC.Types.I# ww3 ->
                           Parser.parseU2 ww1 ww3 typeTok } }
                        : ds3 rest
                        -> case ds3 of wild4 { (,) ds4 ds5 ->
                           case ds4 of wild5 {
                             DEFAULT
                             -> case col of ww { GHC.Types.I# ww1 ->
                                case row of ww2 { GHC.Types.I# ww3 ->
                                Parser.parseU2 ww1 ww3 typeTok } }
                             Lexer.TokenID name
                             -> case ds5 of wild6 { (,) r1 c1 ->
                                case typeTok of wild7 {
                                  DEFAULT
                                  -> case col of ww { GHC.Types.I# ww1 ->
                                     case row of ww2 { GHC.Types.I# ww3 ->
                                     Parser.parseU1 ww1 ww3 wild7 } }
                                  Lexer.TokenVoid -> ((name, Util.VoidType), rest)
                                  Lexer.TokenByte -> ((name, Util.ByteType), rest)
                                  Lexer.TokenInt -> ((name, Util.IntType), rest)
                                  Lexer.TokenBoolean -> ((name, Util.BooleanType), rest)
                                  Lexer.TokenMeggyColorType -> ((name, Util.MeggyColorType), rest)
                                  Lexer.TokenMeggyButtonType -> ((name, Util.MeggyButtonType), rest)
                                  Lexer.TokenMeggyToneType -> ((name, Util.MeggyToneType), rest)
                                  Lexer.TokenIntArrayType -> ((name, Util.IntArrayType), rest)
                                  Lexer.TokenColorArrayType
                                  -> ((name, Util.ColorArrayType), rest) } } } } } } } }) -}
4316a2edf9b9a213f5d29ebaee4355b3
  parseU1 ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Lexer.Token
    -> ((GHC.Base.String, Util.Type),
        [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 3, Strictness: <L,U><L,U><L,U>x -}
a3a4e8d626f00a7f83fd2346786588e3
  parseU2 ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Lexer.Token
    -> ((GHC.Base.String, Util.Type),
        [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 3, Strictness: <L,U><L,U><L,U>x -}
f88d6d6fba80485266598898252d743d
  parseU3 ::
    ((GHC.Base.String, Util.Type),
     [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Strictness: x -}
33bfb6c1422ba8bbed0a51e0b1741674
  parseV ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> ([(GHC.Base.String, Util.Type)],
        [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseV w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
49c1629a5bccc4320aca8794a7d2fbf4
  parseVD ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 let {
                   ds :: (GHC.Base.String, Util.Type,
                          [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                   = case w of wild {
                       []
                       -> case Parser.parseU3
                          ret_ty (GHC.Base.String, Util.Type,
                                  [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                          of {}
                       : ds1 ds2
                       -> case ds1 of wild1 { (,) typeTok ds3 ->
                          case ds3 of wild2 { (,) row col ->
                          case ds2 of wild3 {
                            []
                            -> case col of ww { GHC.Types.I# ww1 ->
                               case row of ww2 { GHC.Types.I# ww3 ->
                               case Parser.parseU2 ww1 ww3 typeTok
                               ret_ty (GHC.Base.String, Util.Type,
                                       [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                               of {} } }
                            : ds4 rest
                            -> case ds4 of wild4 { (,) ds5 ds6 ->
                               case ds5 of wild5 {
                                 DEFAULT
                                 -> case col of ww { GHC.Types.I# ww1 ->
                                    case row of ww2 { GHC.Types.I# ww3 ->
                                    case Parser.parseU2 ww1 ww3 typeTok
                                    ret_ty (GHC.Base.String, Util.Type,
                                            [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                                    of {} } }
                                 Lexer.TokenID name
                                 -> case ds6 of wild6 { (,) r1 c1 ->
                                    case typeTok of wild7 {
                                      DEFAULT
                                      -> case col of ww { GHC.Types.I# ww1 ->
                                         case row of ww2 { GHC.Types.I# ww3 ->
                                         case Parser.parseU1 ww1 ww3 wild7
                                         ret_ty (GHC.Base.String, Util.Type,
                                                 [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
                                         of {} } }
                                      Lexer.TokenVoid -> (name, Util.VoidType, rest)
                                      Lexer.TokenByte -> (name, Util.ByteType, rest)
                                      Lexer.TokenInt -> (name, Util.IntType, rest)
                                      Lexer.TokenBoolean -> (name, Util.BooleanType, rest)
                                      Lexer.TokenMeggyColorType -> (name, Util.MeggyColorType, rest)
                                      Lexer.TokenMeggyButtonType
                                      -> (name, Util.MeggyButtonType, rest)
                                      Lexer.TokenMeggyToneType -> (name, Util.MeggyToneType, rest)
                                      Lexer.TokenIntArrayType -> (name, Util.IntArrayType, rest)
                                      Lexer.TokenColorArrayType
                                      -> (name, Util.ColorArrayType, rest) } } } } } } } }
                 } in
                 (Util.Variable
                    (case ds of ds1 { (,,) vname vtype ts2 -> vtype })
                    (case ds of ds1 { (,,) vname vtype ts2 -> vname }),
                  case ds of ds1 { (,,) vname vtype ts2 -> ts2 })) -}
f1bff13261ed3563f408f415f5d8b810
  parseX ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True) Parser.parseE -}
73ad62fe59d87d0dc79a9fa12cad1479
  parseY ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> ([Util.AST], [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseY w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
7f9b18df13300bb638cbbde753d1d1fa
  parseZ ::
    [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]
    -> (Util.AST, [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(Lexer.Token, (GHC.Types.Int, GHC.Types.Int))]) ->
                 case Parser.$wparseZ w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

